# 右值引用、移动语义和完美转发

移动语义使编译器可以用开销较低的移动操作替换昂贵的拷贝操作（但不是所有情况下移动都会比拷贝快），是 `move-only` 类型对象的支持基础。

完美转发可以将某个函数模板的实参转发给其他函数，转发后的实参保持完全相同的值类型（左值、右值）。

右值引用是移动语义和完美转发的实现基础，它引入了一种新的引用符号（`&&`）来区别于左值引用。

这些名词很直观，但概念上容易与名称类似的函数混淆：

- 移动操作的函数要求传入的实参是右值，无法传入左值，因此需要一个能把左值转换为右值的办法，这就是[std::move ](https://en.cppreference.com/w/cpp/utility/move)做的事。[std::move ](https://en.cppreference.com/w/cpp/utility/move)本身不进行移动，只是将实参强制转换为右值，以允许把转换的结果传给移动函数。
- 完美转发指的是，将函数模板的实参转发给另一个函数，同时保持实参传入给模板时的值类型（传入的实参是左值则转发后仍是左值，是右值则转发后仍是右值）。如果不做任何处理的话，不论是传入的是左值还是右值，在传入之后都会变为左值，因此需要一个转换到右值的操作。[std::move](https://en.cppreference.com/w/cpp/utility/move) 可以做到这点，但它对任何类型都会一视同仁地转为右值。这就需要一个折衷的办法，对左值实参不处理，对右值实参（传入后会变为左值）转换为右值，这就是 [std::foward](https://en.cppreference.com/w/cpp/utility/forward) 所做的事。
- 如果要表示参数是右值，则需要引入一种区别于左值的符号，这就是右值引用符号（`&&`）。右值引用即只能绑定到右值的引用，但其本身是左值（`引用都是左值`）。它只是为了区别于左值引用符号（`&`）而引入的一种符号标记。
- 在模板中，带右值引用符号（`T&&`）并不表示一定是右值引用（这种不确定类型的引用称为转发引用），因为模板参数本身可以带引用符号（`int&`），此时为了使结果合法（`int& &&` 是不合法的），就引入了引用折叠机制（`int& &&`折叠为 `int&*`）。

